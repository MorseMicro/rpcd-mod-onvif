# rpcd-mod-onvif

Use OpenWRT's ubus to discover, interrogate, and instruct ONVIF cameras.

ONVIF is... complex. If I were writing something other than C, I might
be tempted to map ubus directly to onvif, but instead I've cut it down
and drastically simplified it:
- collapsing API requests/responses into a more JSON-ish form
  with less nesting
- pretending that media profiles don't exist by creating them on demand
  when getting a stream with a specified encoder/source

This is a very naive implementation that does not use ubus_defer_request/uloop,
but instead is entirely synchronous. This means that it will block up
rpcd while a call is executing. In particular, be careful with info/probe
calls, which are more likely to take considerable time.

## GSOAP

gsoap is used for the API calls, and the auto-generated/copied files are
in `./soapstuff`; there's also a Makefile there which in theory can
be pointed at a gsoap installation and generate/copy
all the stuff, but things are checked in so it shouldn't be necessary.

Why? Because generating:

 - involves HTTP requests to get the schemas
 - is fragile and just generally complicated
 - is easy to mess up. e.g. don't try to link against a separately
   built libgsoap, because it's important to keep the flags consistent
   (let alone the gsoap versions!)

Because of the gSOAP dependency, it's GPL licensed. Even if one were to
use libgsoap, you still need to compile GPL parts of gSOAP into the code
(plugins, possibly the autogenerated files (?)).

## API description/examples

*Note: SSL is not supported.*

### Error handling

We currently rely on ubus error codes if something goes wrong. Usually
these are not sufficient to diagnose tricky problems, but if you run `rpcd`
manually you can see the output on `stderr`.

Summary:

	UBUS_STATUS_INVALID_ARGUMENT -> the parameters are messed up
	UBUS_STATUS_UNKNOWN_ERROR -> we most likely failed to talk good SOAP to the camera
	                             or blew up in some strange way
	UBUS_STATUS_PERMISSION_DENIED -> you probably didn't provide the correct username/password

### **probe**

This runs a WS-Discovery probe on the first IP address associated with the specified
interface, waiting 5 seconds for whatever tdn:NetworkVideoTransmitters report
back.

Input using default route's interface for multicast. Usually this won't be appropriate, as
if you're running this on a router the default route will your WAN one rather than
your LAN one (which will have your cameras):

	{}

Input using specified interface for multicast:

	{"multicast_ifname": "wlan0"}

Input using specified ip for multicast:

	{"multicast_ip": "192.168.1.1"}

Output:

	{
		"devices": [
			{
				"endpoint_reference_address": "urn:uuid:a2106032-cd36-5da8-aeb5-fe26698a8970",
				"device_url": "http://192.168.1.177:8081/onvif/device_service",
				"types": "tdn:NetworkVideoTransmitter",
				"scopes": "\n                    onvif://www.onvif.org/type/video_encoder\n                    onvif://www.onvif.org/type/ptz\n                    onvif://www.onvif.org/hardware/EKH01%20v2\n                    onvif://www.onvif.org/name/%20EKH01%20v2\n                    onvif://www.onvif.org/location/\n                  "
			}
		]
	}

SOAP methods used:

	wsdd:Probe

### **info**

This gets most of the available information about an ONVIF device, making
numerous API calls.

Note that the 'options' fields reflect ONVIF options calls, showing the
available ranges/values for the settings _at the same nesting level as options_.

Input:

	{
		"device_url": "http://192.168.1.177:8081/onvif/device_service",
		"username":"foo",
		"password":"bar"
	}

Output:

	{
		"hostname": "MorseMicro-599f62",
		"manufacturer": "",
		"model": "EKH01 v2",
		"firmware_version": "rel_2_1_2_2023_Mar_17^0",
		"serial_number": "100000005023fd25",
		"hardware_id": "MorseMicro-599f62",
		"imaging_url": "http://192.168.1.177:8081/onvif/imaging_service",
		"media_url": "http://192.168.1.177:8081/onvif/media_service",
		"media": {
			"encoders": {
				"encoder_config_token": {
					"encoding": "H264",
					"profile": "High",
					"quality": 0,
					"govlength": 60,
					"framerate": 30,
					"bitrate": 10000,
					"resolution": {
						"width": 640,
						"height": 480
					},
					"options": {
						"quality_range": {
							"min": 1,
							"max": 1
						},
						"encoding": {
							"H264": {
								"profile": [ "Baseline", "Main", "High" ],
								"resolution": [
									{ "width": 640, "height": 480 },
									{ "width": 1280, "height": 720 },
									{ "width": 1920, "height": 1080 }
								],
								"framerate_range": {
									"min": 2,
									"max": 30
								},
								"govlength_range": {
									"min": 1,
									"max": 512
								},
								"encodinginterval_range": [ 1, 1 ]
							}
						}
					}
				}
			},
			"sources": {
				"video_src_token": {
					"framerate": 25,
					"resolution": {
						"width": 1920,
						"height": 1280
					},
					"configs": {
						"video_src_config_token": {
							"bounds": { "x": 0, "y": 0, "width": 1920, "height": 1080 }
						}
					},
					"imaging": {
						"brightness": 50.000000,
						"options": {
							"brightness_range": {
								"min": 0.000000,
								"max": 100.000000
							}
						}
					}
				}
			}
		}
	}

SOAP methods used:

	tds:GetHostname
	tds:GetDeviceInformation
	tds:GetServices
	trt:GetVideoEncoderConfigurations
	trt:GetVideoEncoderConfigurationOptions
	trt:GetVideoSources
	trt:GetVideoSourceConfigurations
	timg:GetImagingSettings
	timg:GetOptions

### **set_imaging**

All imaging settings (e.g. brightness/contrast) are optional, and if not provided
the current settings are maintained.

Input:

	{
		"imaging_url": "http://192.168.1.177:8081/onvif/imaging_service",
		"username":"foo", "password":"bar",
		"source_token": "video_src_token",
		"settings": {
			"brightness": 50.0,
			"contrast": 50.0
		}
	}

SOAP methods used:

	timg:GetImagingSettings
	timg:SetImagingSettings

### **set_encoder**

All encoder configuration (e.g. resolution/encoding/...) is optional, and if not provided
the current settings are maintained.

Input:

	{
		"media_url": "http://192.168.1.177:8081/onvif/media_service",
		"username": "foo", "password": "bar",
		"encoder_token": "encoder_config_token",
		"config": {
			"framerate": 30,
			"encoding": "H264",
			"govlength": 1,
			"quality": 1,
			"profile": "High",
			"resolution": {
				"height": 480,
				"width": 640
			}
		}
	}

SOAP methods used:

	trt:GetVideoEncoderConfiguration
	trt:SetVideoEncoderConfiguration

### **get_stream**

Get a stream associated with a video source and encoder, tokens for which are accessible
via the **info** call above. Note that unlike set_imaging, get_stream uses the source
token, you must provide the source config token.

Under the hood, this gets all media profiles, attempting to find one with the
correct encoder_token and source_config_token. If none have the correct config,
then creates a new profile with a UUID token and adds the appropriate encoder/source
config. However, because the ONVIF server used for testing did not support
this, the codepath hasn't been exercised and may not work.

Input:

	{
		"media_url": "http://192.168.1.177:8081/onvif/media_service",
		"username":"foo", "password":"bar",
		"source_config_token": "video_src_config_token",
		"encoder_token": "encoder_config_token"
	}

Output:

	{
		"stream_url": "rtsp://192.168.1.177:8554/h264"
	}

SOAP methods used:

	trt:GetProfiles
	trt:GetStreamUri

If no appropriate profile exists, the following methods are also used:

	trt:CreateProfile
	trt:AddVideoEncoderConfiguration
	trt:AddVideoSourceConfiguration
